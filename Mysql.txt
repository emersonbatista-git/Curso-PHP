- Banco de dados contem tabelas
- Tabelas contem registros
- Registros contem campos 
- Tipos de comandos, DDL (Data Definition Language) CREATE DATABASE,  CREATE TABLE, ALTER TABLE, DROP TABLE
                     DML (Data Manipulation Language) INSERT INTO, UPDATE, DELETE, TRUNCATE
                     DQL (Data Query Language) SELECT

* Criar banco de dados:

create database cadastro
default character set utf8mb4
default collate utf8mb4_general_ci;

* Deletar banco de dados:

drop database cadastro;

*Criar tabelas  e os campos:
Definir uma chave primaria para que nao tenha registros duplicados. Foi criado o ID com auto incremento, o banco irá seguir a seuquencia

create table pessoas (
id int not null auto_increment,
nome varchar(30) NOT NULL,
nascimento DATE,
sexo enum ('M' , 'F'),
peso decimal (5,2),
altura decimal (3,2),
nascionalidade varchar(20)
 default 'Brasil',
 primary key (id) )
 default charset = utf8mb4;



Obs, podemos utilizar crase nos nomes dos campos para permitir espaço, acentos, etc...


* Descrever uma tabela

describe pessoas;



create table pessoas (
id int not null auto_increment,
nome varchar(30) NOT NULL,
nascimento DATE,
sexo enum ('M' , 'F'),
peso decimal (5,2),
altura decimal (3,2),
nascionalidade varchar(20)
 default 'Brasil',
 primary key (id) )
 default charset = utf8mb4;


*Inserir dados nas tabelas
Nao é necessario informar o ID, uma vez que definimos como auto_increment

insert into pessoas
(nome, nascimaneto, sexo, peso, altura, nacionalidade)
values
('Godofredo', '1984-01-02', 'M', '78.5', '1.83', 'Brasil');

ou

(default,'Maria', '1989-03-02', 'F', '58.5', '1.68', default); o ID como defaut ira seguir  sequencia e a nascionalidade tambem por ter definido Brasil

*Se a ordem for exatamente a mesma que será inserida, nao é necessario informar os campos:

insert into pessoas values
(default,'Creuza', '1990-03-02', 'F', '58.5', '1.68', default);

* para inserir mais registros, informe ";" somente no final do comando

insert into pessoas values
(default,'João', '1993-03-02', 'M', '88.5', '1.76', default),
(default,'Maria', '1996-07-02', 'F', '68.5', '1.65', default),
(default,'Pedro', '1998-09-02', 'M', '98.5', '1.80', default),
(default,'Lucas', '1999-08-02', 'M', '78.5', '1.72', default);


*Alterar a estrutura da tabela
- Acrescentar coluna

alter table pessoas
add column profissao varchar(10);

-Caso queira definir onde será criada

alter table pessoas
add column profissao varchar(10) after nome;

alter table pessoas
add column profissao varchar(10) firts;


-Remover coluna

alter table pessoas
drop column profissao;

- Modificar definição

alter table pessoas
modify column profissao varchar(20);

- Renomear coluna

alter table pessoas
change column profissao prof varchar(20);

- Renomear a tabela

alter table pessoas rename to gafanhotos;

- Deletar a tabela

drop table if exists alunos;

*** Manipulando linhas*****

update cursos set nome = 'HTML5' where idcurso = 1;

update cursos set nome = 'PHP', ano = '2015' where idcurso = 4;

update cursos set nome = 'JAVA', ano = '2015', carga = '40' where idcurso = 5 limit 1;

delete from cursos where idcurso in (9,10);

truncate cursos;  ****Apaga toda a tabela*****


****COMANDO SELECT******

select *from cursos;   (seleciona todos os registros da tabela por ordem da chave primaria)

select *from cursos order by nome; (organizou pela coluna nome e ficou em oprdem alfabetica)

select *from cursos order by nome desc; (organizou de forma decrecente)

select ano, carga, nome from cursos order by ano; (pode selecionar apenas algumas colunas e na ordem que quer trazer)

select ano, carga, nome from cursos order by ano, nome; (pode ordenar por mais de uma situação)

select * from cursos where ano = '2016' order by nome; (filtrar por linhas)

select nome, carga from cursos where ano = '2016' order by nome; (selecionou apenas algumas colunas)

select nome, descricao from cursos where ano <= '2015' order by nome; (selecionou menor ouo igual ao ano)

select nome, ano from cursos where ano between '2014' and '2016' order by ano desc, nome asc; (betwenn entre alguma variavel, e com ordenação diferente, uam decendente e ou ascendente)

select nome, ano from cursos where ano in ('2014', '2016'); (selecionar apenas alguns valores)

select *from cursos where carga > 35 and totaulas < 30; ( atender as duas condiçoes)

select *from cursos where carga > 35 or totaulas < 30;  (atender uma ou outra condição)

select * from cursos where nome like 'P%'; (irá trazer todos os registros que comecem com p, se colocar %p termina com p e %p% traz se houver p na palavra)

select * from cursos where nome not like '%P%'; (irá trazer todos os registros que nao tem letra p no nome)

select * from cursos where nome like 'ph%p'; (irá trazer o que comece com ph e termine com p)

select * from cursos where nome like 'ph%p_'; (irá trazer o que comece com ph, tenha alguma coisa no meio,  termine com p e seguido de alguma coisa)

select * from cursos where nome like 'p__t%'; (irá trazer o que começa copm p, tem duas letra e em seguida a letra t)

select distinct nacionalidade from gafanhotos; (neste exemplo irá trazer os paises sem repetir, se houver 3 iguais, irá trazer o nome apenas uma vez)

select count(*) from cursos;  // select count(*) from cursos where carga > 40;(Neste caso irá contar quantos registros tem na tabela, posso colocar o nome da coluna no lugar do asteristico)

select max(carga) from cursos; ( irá selecionar o maior valor na coluna)

select nome, min(carga) from cursos; ( irá selecionar o menor valor na coluna e trazer o nome do curso)

select sum(totaulas) from cursos; (soma todos os valores)

select avg(totaulas) from cursos; (soma todos os valores e tira uma media)

select carga from cursos group by carga; (agrupa os valores iguais)

select carga, count(nome) from cursos group by carga; (agrupa e mostra quantos tem em cada resultado)

select ano, count(*) from cursos group by ano having count(ano) >= 5 order by count(*); (Trouxe somente os que tem o contador maior que 5 e ordenou pelo contador)

select ano, count(*) from cursos where totaulas > 30 group by ano having ano > 2013 order by count(*); (Havin funciona no mesmo campo do agrupamento)

select carga, count(*) from cursos where ano > 2015 group by carga having carga > (select avg(carga) from cursos); (Selecionei, agrupei e selecionei dentro do select)


*******RELACIONAMENTOS DAS TABELAS********

Chave primaria - Chave que nao pode ser igual, ID

Chave estrageira - É a chave primaria que será gravada em outra tabela para ser a referencia, idcliente grava o id na tabela do endereço, neste caso existe a primaria
                   id_endereço, relacionou o cliente e seu endereço.

InnoDB e XtraDB  - Suportam a regra ACID, sao as quatro regras de uma boa transação no banco de dados e permite chaves estrageiras
                   A - Atomicidade, toda tarefa é feita ou nada será executado
                   C - Concistencia, Se antes da transação o baco estava estavel, após a transação tem que esta. Senao, volte ao estado anterior
                   I - Isolamento, duas operações simultaneas, uma nao interfere na outra
                   D - Durabilidade, irá durar o tempo que seja necessario.

Para relacionamentos n (muitos) para 1, coloca a chave primaria do lado 1 na tabela do n, cria no n uma coluna para armazenar a chave primaria do 1. Nao precisa ter o mesmo nome mas tem que ser do mesmo tipo e tamanho

Gafanhoto n -------- 1 curso

id                     idcurso
idcurso



describe gafanhotos;

select *from gafanhotos;

alter table gafanhotos add column idcurso int;

alter table gafanhotos add foreign key (idcurso) references cursos(idcurso);

update gafanhotos set idcurso = '6' where id = '1';


*** JUNÇOES *****

join ou inner join

* Irá juntar todos que tem relação, os que nao tiverem nao irá apresentar

Neste exemplo irá juntar todos os alunos com todos os curso, irá repetir 1 primeiro com todos os cursos, depois o segundo com todos os curso, etc..

   select gafanhotos.nome, gafanhotos.idcurso, cursos.nome, cursos.ano from gafanhotos join cursos;

Para resolver isso, iremos colocar uma condição relacionando a chave estrangeira

   select gafanhotos.nome, cursos.nome, cursos.ano from gafanhotos join cursos on cursos.idcurso = gafanhotos.idcurso order by gafanhotos.nome;

Podemos colocar apelido na tabela durante o select, com o comando " as "

   select g.nome, c.nome, c.ano from gafanhotos as g join cursos as c on c.idcurso = g.idcurso order by g.nome;


outer join

* Irá trazer ate os que nao tem relacionamento, porem temos que definir uma priridade de tabela, localize o comando join e voce terá uma tabela a esquerda e uma a   direita

Se quiser que a da esquerda seja a preferencial:

    select g.nome, c.nome, c.ano from gafanhotos as g left outer join cursos as c on c.idcurso = g.idcurso;

Se quiser preferencia a da direita, podemos colocar right join ou apenas join

    select g.nome, c.nome, c.ano from gafanhotos as g right outer join cursos as c on c.idcurso = g.idcurso;


****** RELACIONAMENTO MUITOS PRA MUITOS *******

Quando houver relacionamento muitos para muitos, cria uma nova tabela para fazer o relacionamento

gafanhoto 1     n assite n    1 curso

create table gafanhoto_assite_curso (
id int not null auto_increment,
Data date,
idgafanhoto int,
idcurso int,
primary key (id),
foreign key (idgafanhoto) references gafanhotos(id),
foreign key (idcurso) references cursos(idcurso)

) default charset = utf8;




select g.id, g.nome, a.idgafanhoto, id_curso from  gafanhotos as g
join gafanhoto_assite_curso as a
on g.id = a.idgafanhoto;

select g.nome, id_curso from  gafanhotos as g
join gafanhoto_assite_curso as a
on g.id = a.idgafanhoto order by g.nome;


select g.nome, c.nome from gafanhotos as g
join gafanhoto_assite_curso as a
on g.id = a.idgafanhoto
join cursos as c
on c.idcurso = a.id_curso
 order by g.nome;


















































